!function (e) { "use strict"; var t = {}, i = t, n = "object" == typeof module && module.exports, o = "function" == typeof define && define.amd; n ? module.exports = t : o ? define([], t) : e.Pizzicato = e.Pz = t; var s = e.AudioContext || e.webkitAudioContext; if (!s) { console.error("No AudioContext found in this environment. Please ensure your window or global object contains a working AudioContext constructor function."); return } t.context = new s; var a = t.context.createGain(); a.connect(t.context.destination), t.Util = { isString: function (e) { return "[object String]" === toString.call(e) }, isObject: function (e) { return "[object Object]" === toString.call(e) }, isFunction: function (e) { return "[object Function]" === toString.call(e) }, isNumber: function (e) { return "[object Number]" === toString.call(e) && e === +e }, isArray: function (e) { return "[object Array]" === toString.call(e) }, isInRange: function (e, t, n) { return !!(i.Util.isNumber(e) && i.Util.isNumber(t) && i.Util.isNumber(n)) && e >= t && e <= n }, isBool: function (e) { return "boolean" == typeof e }, isOscillator: function (e) { return e && "[object OscillatorNode]" === e.toString() }, isAudioBufferSourceNode: function (e) { return e && "[object AudioBufferSourceNode]" === e.toString() }, isSound: function (e) { return e instanceof i.Sound }, isEffect: function (e) { for (var i in t.Effects) if (e instanceof t.Effects[i]) return !0; return !1 }, normalize: function (e, t, n) { if (i.Util.isNumber(e) && i.Util.isNumber(t) && i.Util.isNumber(n)) return (n - t) * e / 1 + t }, getDryLevel: function (e) { return !i.Util.isNumber(e) || e > 1 || e < 0 ? 0 : e <= .5 ? 1 : 1 - (e - .5) * 2 }, getWetLevel: function (e) { return !i.Util.isNumber(e) || e > 1 || e < 0 ? 0 : e >= .5 ? 1 : 1 - (.5 - e) * 2 } }; var r = Object.getPrototypeOf(Object.getPrototypeOf(t.context.createGain())), c = r.connect; r.connect = function (e) { var t = i.Util.isEffect(e) ? e.inputNode : e; return c.call(this, t), e }, Object.defineProperty(t, "volume", { enumerable: !0, get: function () { return a.gain.value }, set: function (e) { i.Util.isInRange(e, 0, 1) && a && (a.gain.value = e) } }), Object.defineProperty(t, "masterGainNode", { enumerable: !1, get: function () { return a }, set: function (e) { console.error("Can't set the master gain node") } }), t.Events = { on: function (e, t, i) { e && t && (this._events = this._events || {}, (this._events[e] || (this._events[e] = [])).push({ callback: t, context: i || this, handler: this })) }, trigger: function (e) { var t, i, n, o; if (e) { for (this._events = this._events || {}, t = this._events[e] || (this._events[e] = []), o = 0, i = Math.max(0, arguments.length - 1), n = []; o < i; o++)n[o] = arguments[o + 1]; for (o = 0; o < t.length; o++)t[o].callback.apply(t[o].context, n) } }, off: function (e) { e ? this._events[e] = void 0 : this._events = {} } }, t.Sound = function (e, n) { var o = this, s = t.Util, a = function e(t) { if (t && !s.isFunction(t) && !s.isString(t) && !s.isObject(t)) return "Description type not supported. Initialize a sound using an object, a function or a string."; if (s.isObject(t)) { if (!s.isString(t.source) || -1 === ["wave", "file", "input", "script", "sound"].indexOf(t.source)) return "Specified source not supported. Sources can be wave, file, input or script"; if ("file" === t.source && (!t.options || !t.options.path)) return "A path is needed for sounds with a file source"; if ("script" === t.source && (!t.options || !t.options.audioFunction)) return "An audio function is needed for sounds with a script source" } }(e), r = s.isObject(e) && s.isObject(e.options); if (a) throw console.error(a), Error("Error initializing Pizzicato Sound: " + a); function c(e, n) { e = e || {}, this.getRawSourceNode = function () { var i = this.sourceNode ? this.sourceNode.frequency.value : e.frequency, n = t.context.createOscillator(); return n.type = e.type || "sine", n.frequency.value = i || 440, n }, this.sourceNode = this.getRawSourceNode(), this.sourceNode.gainSuccessor = i.context.createGain(), this.sourceNode.connect(this.sourceNode.gainSuccessor), s.isFunction(n) && n() } function u(e, i) { e = s.isArray(e) ? e : [e]; var n = new XMLHttpRequest; n.open("GET", e[0], !0), n.responseType = "arraybuffer", n.onload = function (n) { t.context.decodeAudioData(n.target.response, (function (e) { o.getRawSourceNode = function () { var i = t.context.createBufferSource(); return i.loop = this.loop, i.buffer = e, i }, s.isFunction(i) && i() }).bind(o), (function (t) { if (console.error("Error decoding audio file " + e[0]), e.length > 1) { e.shift(), u(e, i); return } t = t || Error("Error decoding audio file " + e[0]), s.isFunction(i) && i(t) }).bind(o)) }, n.onreadystatechange = function (t) { 4 === n.readyState && 200 !== n.status && console.error("Error while fetching " + e[0] + ". " + n.statusText) }, n.send() } function h(e, i) { var n = s.isFunction(e) ? e : e.audioFunction, o = s.isObject(e) && e.bufferSize ? e.bufferSize : null; if (!o) try { t.context.createScriptProcessor() } catch (a) { o = 2048 } this.getRawSourceNode = function () { var e = t.context.createScriptProcessor(o, 1, 1); return e.onaudioprocess = n, e } } this.detached = r && e.options.detached, this.masterVolume = t.context.createGain(), this.fadeNode = t.context.createGain(), this.fadeNode.gain.value = 0, this.detached || this.masterVolume.connect(t.masterGainNode), this.lastTimePlayed = 0, this.effects = [], this.effectConnectors = [], this.playing = this.paused = !1, this.loop = r && e.options.loop, this.attack = r && s.isNumber(e.options.attack) ? e.options.attack : .04, this.volume = r && s.isNumber(e.options.volume) ? e.options.volume : 1, r && s.isNumber(e.options.release) ? this.release = e.options.release : r && s.isNumber(e.options.sustain) ? (console.warn("'sustain' is deprecated. Use 'release' instead."), this.release = e.options.sustain) : this.release = .04, e ? s.isString(e) ? u.bind(this)(e, n) : s.isFunction(e) ? h.bind(this)(e, n) : "file" === e.source ? u.bind(this)(e.options.path, n) : "wave" === e.source ? c.bind(this)(e.options, n) : "input" === e.source ? (function e(i, n) { if (navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, !navigator.getUserMedia) { console.error("Your browser does not support getUserMedia"); return } navigator.getUserMedia({ audio: !0 }, (function (e) { o.getRawSourceNode = function () { return t.context.createMediaStreamSource(e) }, s.isFunction(n) && n() }).bind(o), function (e) { s.isFunction(n) && n(e) }) }).bind(this)(e, n) : "script" === e.source ? h.bind(this)(e.options, n) : "sound" === e.source && (function e(t, n) { this.getRawSourceNode = t.sound.getRawSourceNode, t.sound.sourceNode && i.Util.isOscillator(t.sound.sourceNode) && (this.sourceNode = this.getRawSourceNode(), this.frequency = t.sound.frequency) }).bind(this)(e.options, n) : c.bind(this)({}, n) }, t.Sound.prototype = Object.create(t.Events, { play: { enumerable: !0, value: function (e, n) { this.playing || (i.Util.isNumber(n) || (n = this.offsetTime || 0), i.Util.isNumber(e) || (e = 0), this.playing = !0, this.paused = !1, this.sourceNode = this.getSourceNode(), this.applyAttack(), i.Util.isFunction(this.sourceNode.start) && (this.lastTimePlayed = t.context.currentTime - n, this.sourceNode.start(i.context.currentTime + e, n)), this.trigger("play")) } }, stop: { enumerable: !0, value: function () { (this.paused || this.playing) && (this.paused = this.playing = !1, this.stopWithRelease(), this.offsetTime = 0, this.trigger("stop")) } }, pause: { enumerable: !0, value: function () { if (!this.paused && this.playing) { this.paused = !0, this.playing = !1, this.stopWithRelease(); var e = i.context.currentTime - this.lastTimePlayed; this.sourceNode.buffer ? this.offsetTime = e % (this.sourceNode.buffer.length / i.context.sampleRate) : this.offsetTime = e, this.trigger("pause") } } }, clone: { enumerable: !0, value: function () { for (var e = new t.Sound({ source: "sound", options: { loop: this.loop, attack: this.attack, release: this.release, volume: this.volume, sound: this } }), i = 0; i < this.effects.length; i++)e.addEffect(this.effects[i]); return e } }, onEnded: { enumerable: !0, value: function (e) { return function () { this.sourceNode && this.sourceNode !== e || (this.playing && this.stop(), this.paused || this.trigger("end")) } } }, addEffect: { enumerable: !0, value: function (e) { if (!i.Util.isEffect(e)) return console.error("The object provided is not a Pizzicato effect."), this; this.effects.push(e); var t = this.effectConnectors.length > 0 ? this.effectConnectors[this.effectConnectors.length - 1] : this.fadeNode; t.disconnect(), t.connect(e); var n = i.context.createGain(); return this.effectConnectors.push(n), e.connect(n), n.connect(this.masterVolume), this } }, removeEffect: { enumerable: !0, value: function (e) { var t, i = this.effects.indexOf(e); if (-1 === i) return console.warn("Cannot remove effect that is not applied to this sound."), this; var n = this.playing; n && this.pause(); var o = 0 === i ? this.fadeNode : this.effectConnectors[i - 1]; o.disconnect(); var s = this.effectConnectors[i]; return s.disconnect(), e.disconnect(s), this.effectConnectors.splice(i, 1), this.effects.splice(i, 1), t = i > this.effects.length - 1 || 0 === this.effects.length ? this.masterVolume : this.effects[i], o.connect(t), n && this.play(), this } }, connect: { enumerable: !0, value: function (e) { return this.masterVolume.connect(e), this } }, disconnect: { enumerable: !0, value: function (e) { return this.masterVolume.disconnect(e), this } }, connectEffects: { enumerable: !0, value: function () { for (var e = [], t = 0; t < this.effects.length; t++) { var n = t === this.effects.length - 1 ? this.masterVolume : this.effects[t + 1].inputNode; e[t] = i.context.createGain(), this.effects[t].outputNode.disconnect(this.effectConnectors[t]), this.effects[t].outputNode.connect(n) } } }, volume: { enumerable: !0, get: function () { if (this.masterVolume) return this.masterVolume.gain.value }, set: function (e) { i.Util.isInRange(e, 0, 1) && this.masterVolume && (this.masterVolume.gain.value = e) } }, frequency: { enumerable: !0, get: function () { return this.sourceNode && i.Util.isOscillator(this.sourceNode) ? this.sourceNode.frequency.value : null }, set: function (e) { this.sourceNode && i.Util.isOscillator(this.sourceNode) && (this.sourceNode.frequency.value = e) } }, sustain: { enumerable: !0, get: function () { return console.warn("'sustain' is deprecated. Use 'release' instead."), this.release }, set: function (e) { console.warn("'sustain' is deprecated. Use 'release' instead."), i.Util.isInRange(e, 0, 10) && (this.release = e) } }, getSourceNode: { enumerable: !0, value: function () { if (this.sourceNode) { var e = this.sourceNode; e.gainSuccessor.gain.setValueAtTime(e.gainSuccessor.gain.value, i.context.currentTime), e.gainSuccessor.gain.linearRampToValueAtTime(1e-4, i.context.currentTime + .2), setTimeout(function () { e.disconnect(), e.gainSuccessor.disconnect() }, 200) } var t = this.getRawSourceNode(); return t.gainSuccessor = i.context.createGain(), t.connect(t.gainSuccessor), t.gainSuccessor.connect(this.fadeNode), this.fadeNode.connect(this.getInputNode()), i.Util.isAudioBufferSourceNode(t) && (t.onended = this.onEnded(t).bind(this)), t } }, getInputNode: { enumerable: !0, value: function () { return this.effects.length > 0 ? this.effects[0].inputNode : this.masterVolume } }, applyAttack: { enumerable: !1, value: function () { var e = this.fadeNode.gain.value; if (this.fadeNode.gain.cancelScheduledValues(i.context.currentTime), this.fadeNode.gain.setValueAtTime(e, i.context.currentTime), !this.attack) { this.fadeNode.gain.setValueAtTime(1, t.context.currentTime); return } var n = (1 - this.fadeNode.gain.value) * this.attack; this.fadeNode.gain.setValueAtTime(this.fadeNode.gain.value, t.context.currentTime), this.fadeNode.gain.linearRampToValueAtTime(1, t.context.currentTime + n) } }, stopWithRelease: { enumerable: !1, value: function (e) { var n = this.sourceNode, o = function () { return i.Util.isFunction(n.stop) ? n.stop(0) : n.disconnect() }, s = this.fadeNode.gain.value; if (this.fadeNode.gain.cancelScheduledValues(i.context.currentTime), this.fadeNode.gain.setValueAtTime(s, i.context.currentTime), !this.release) { o(); return } var a = this.fadeNode.gain.value * this.release; this.fadeNode.gain.setValueAtTime(this.fadeNode.gain.value, t.context.currentTime), this.fadeNode.gain.linearRampToValueAtTime(1e-5, t.context.currentTime + a), window.setTimeout(function () { o() }, 1e3 * a) } } }), t.Group = function (e) { e = e || [], this.mergeGainNode = i.context.createGain(), this.masterVolume = i.context.createGain(), this.sounds = [], this.effects = [], this.effectConnectors = [], this.mergeGainNode.connect(this.masterVolume), this.masterVolume.connect(i.masterGainNode); for (var t = 0; t < e.length; t++)this.addSound(e[t]) }, t.Group.prototype = Object.create(i.Events, { connect: { enumerable: !0, value: function (e) { return this.masterVolume.connect(e), this } }, disconnect: { enumerable: !0, value: function (e) { return this.masterVolume.disconnect(e), this } }, addSound: { enumerable: !0, value: function (e) { if (!i.Util.isSound(e)) { console.error("You can only add Pizzicato.Sound objects"); return } if (this.sounds.indexOf(e) > -1) { console.warn("The Pizzicato.Sound object was already added to this group"); return } e.detached && console.warn("Groups do not support detached sounds. You can manually create an audio graph to group detached sounds together."), e.disconnect(i.masterGainNode), e.connect(this.mergeGainNode), this.sounds.push(e) } }, removeSound: { enumerable: !0, value: function (e) { var t = this.sounds.indexOf(e); if (-1 === t) { console.warn("Cannot remove a sound that is not part of this group."); return } e.disconnect(this.mergeGainNode), e.connect(i.masterGainNode), this.sounds.splice(t, 1) } }, volume: { enumerable: !0, get: function () { if (this.masterVolume) return this.masterVolume.gain.value }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.masterVolume.gain.value = e) } }, play: { enumerable: !0, value: function () { for (var e = 0; e < this.sounds.length; e++)this.sounds[e].play(); this.trigger("play") } }, stop: { enumerable: !0, value: function () { for (var e = 0; e < this.sounds.length; e++)this.sounds[e].stop(); this.trigger("stop") } }, pause: { enumerable: !0, value: function () { for (var e = 0; e < this.sounds.length; e++)this.sounds[e].pause(); this.trigger("pause") } }, addEffect: { enumerable: !0, value: function (e) { if (!i.Util.isEffect(e)) return console.error("The object provided is not a Pizzicato effect."), this; this.effects.push(e); var t = this.effectConnectors.length > 0 ? this.effectConnectors[this.effectConnectors.length - 1] : this.mergeGainNode; t.disconnect(), t.connect(e); var n = i.context.createGain(); return this.effectConnectors.push(n), e.connect(n), n.connect(this.masterVolume), this } }, removeEffect: { enumerable: !0, value: function (e) { var t, i = this.effects.indexOf(e); if (-1 === i) return console.warn("Cannot remove effect that is not applied to this group."), this; var n = 0 === i ? this.mergeGainNode : this.effectConnectors(i - 1); n.disconnect(); var o = this.effectConnectors[i]; return o.disconnect(), e.disconnect(o), this.effectConnectors.splice(i, 1), this.effects.splice(i, 1), t = i > this.effects.length - 1 || 0 === this.effects.length ? this.masterVolume : this.effects[i], n.connect(t), this } } }), t.Effects = {}; var u = Object.create(null, { connect: { enumerable: !0, value: function (e) { return this.outputNode.connect(e), this } }, disconnect: { enumerable: !0, value: function (e) { return this.outputNode.disconnect(e), this } } }); function h(e, n) { this.options = {}, e = e || this.options; var o = { frequency: 350, peak: 1 }; for (var s in this.inputNode = this.filterNode = i.context.createBiquadFilter(), this.filterNode.type = n, this.outputNode = t.context.createGain(), this.filterNode.connect(this.outputNode), o) this[s] = e[s], this[s] = void 0 === this[s] || null === this[s] ? o[s] : this[s] } t.Effects.Delay = function (e) { this.options = {}, e = e || this.options; var i = { feedback: .5, time: .3, mix: .5 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.feedbackGainNode = t.context.createGain(), this.delayNode = t.context.createDelay(), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.delayNode.connect(this.feedbackGainNode), this.feedbackGainNode.connect(this.delayNode), this.inputNode.connect(this.delayNode), this.delayNode.connect(this.wetGainNode), this.wetGainNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.Delay.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } }, time: { enumerable: !0, get: function () { return this.options.time }, set: function (e) { i.Util.isInRange(e, 0, 180) && (this.options.time = e, this.delayNode.delayTime.value = e) } }, feedback: { enumerable: !0, get: function () { return this.options.feedback }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.feedback = parseFloat(e, 10), this.feedbackGainNode.gain.value = this.feedback) } } }), t.Effects.Compressor = function (e) { this.options = {}, e = e || this.options; var i = { threshold: -24, knee: 30, attack: .003, release: .25, ratio: 12 }; for (var n in this.inputNode = this.compressorNode = t.context.createDynamicsCompressor(), this.outputNode = t.context.createGain(), this.compressorNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.Compressor.prototype = Object.create(u, { threshold: { enumerable: !0, get: function () { return this.compressorNode.threshold.value }, set: function (e) { t.Util.isInRange(e, -100, 0) && (this.compressorNode.threshold.value = e) } }, knee: { enumerable: !0, get: function () { return this.compressorNode.knee.value }, set: function (e) { t.Util.isInRange(e, 0, 40) && (this.compressorNode.knee.value = e) } }, attack: { enumerable: !0, get: function () { return this.compressorNode.attack.value }, set: function (e) { t.Util.isInRange(e, 0, 1) && (this.compressorNode.attack.value = e) } }, release: { enumerable: !0, get: function () { return this.compressorNode.release.value }, set: function (e) { t.Util.isInRange(e, 0, 1) && (this.compressorNode.release.value = e) } }, ratio: { enumerable: !0, get: function () { return this.compressorNode.ratio.value }, set: function (e) { t.Util.isInRange(e, 1, 20) && (this.compressorNode.ratio.value = e) } }, getCurrentGainReduction: function () { return this.compressorNode.reduction } }), t.Effects.LowPassFilter = function (e) { h.call(this, e, "lowpass") }, t.Effects.HighPassFilter = function (e) { h.call(this, e, "highpass") }; var d = Object.create(u, { frequency: { enumerable: !0, get: function () { return this.filterNode.frequency.value }, set: function (e) { t.Util.isInRange(e, 10, 22050) && (this.filterNode.frequency.value = e) } }, peak: { enumerable: !0, get: function () { return this.filterNode.Q.value }, set: function (e) { t.Util.isInRange(e, 1e-4, 1e3) && (this.filterNode.Q.value = e) } } }); function l() { var e, n, o = i.context.sampleRate * this.time, s = t.context.createBuffer(2, o, i.context.sampleRate), a = s.getChannelData(0), r = s.getChannelData(1); for (n = 0; n < o; n++)e = this.reverse ? o - n : n, a[n] = (2 * Math.random() - 1) * Math.pow(1 - e / o, this.decay), r[n] = (2 * Math.random() - 1) * Math.pow(1 - e / o, this.decay); this.reverbNode.buffer = s } t.Effects.LowPassFilter.prototype = d, t.Effects.HighPassFilter.prototype = d, t.Effects.Distortion = function (e) { this.options = {}, e = e || this.options; var i = { gain: .5 }; for (var n in this.waveShaperNode = t.context.createWaveShaper(), this.inputNode = this.outputNode = this.waveShaperNode, i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.Distortion.prototype = Object.create(u, { gain: { enumerable: !0, get: function () { return this.options.gain }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.gain = e, this.adjustGain()) } }, adjustGain: { writable: !1, configurable: !1, enumerable: !1, value: function () { for (var e, t = i.Util.isNumber(this.options.gain) ? parseInt(100 * this.options.gain, 10) : 50, n = new Float32Array(44100), o = Math.PI / 180, s = 0; s < 44100; ++s)e = 2 * s / 44100 - 1, n[s] = (3 + t) * e * 20 * o / (Math.PI + t * Math.abs(e)); this.waveShaperNode.curve = n } } }), t.Effects.Flanger = function (e) { this.options = {}, e = e || this.options; var i = { time: .45, speed: .2, depth: .1, feedback: .1, mix: .5 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), this.inputFeedbackNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.delayNode = t.context.createDelay(), this.oscillatorNode = t.context.createOscillator(), this.gainNode = t.context.createGain(), this.feedbackNode = t.context.createGain(), this.oscillatorNode.type = "sine", this.inputNode.connect(this.inputFeedbackNode), this.inputNode.connect(this.dryGainNode), this.inputFeedbackNode.connect(this.delayNode), this.inputFeedbackNode.connect(this.wetGainNode), this.delayNode.connect(this.wetGainNode), this.delayNode.connect(this.feedbackNode), this.feedbackNode.connect(this.inputFeedbackNode), this.oscillatorNode.connect(this.gainNode), this.gainNode.connect(this.delayNode.delayTime), this.dryGainNode.connect(this.outputNode), this.wetGainNode.connect(this.outputNode), this.oscillatorNode.start(0), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.Flanger.prototype = Object.create(u, { time: { enumberable: !0, get: function () { return this.options.time }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.time = e, this.delayNode.delayTime.value = i.Util.normalize(e, .001, .02)) } }, speed: { enumberable: !0, get: function () { return this.options.speed }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.speed = e, this.oscillatorNode.frequency.value = i.Util.normalize(e, .5, 5)) } }, depth: { enumberable: !0, get: function () { return this.options.depth }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.depth = e, this.gainNode.gain.value = i.Util.normalize(e, 5e-4, .005)) } }, feedback: { enumberable: !0, get: function () { return this.options.feedback }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.feedback = e, this.feedbackNode.gain.value = i.Util.normalize(e, 0, .8)) } }, mix: { enumberable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } } }), t.Effects.StereoPanner = function (e) { this.options = {}, e = e || this.options; var i = { pan: 0 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), t.context.createStereoPanner ? (this.pannerNode = t.context.createStereoPanner(), this.inputNode.connect(this.pannerNode), this.pannerNode.connect(this.outputNode)) : this.inputNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.StereoPanner.prototype = Object.create(u, { pan: { enumerable: !0, get: function () { return this.options.pan }, set: function (e) { i.Util.isInRange(e, -1, 1) && (this.options.pan = e, this.pannerNode && (this.pannerNode.pan.value = e)) } } }), t.Effects.Convolver = function (e, n) { this.options = {}, e = e || this.options; var o = this, s = new XMLHttpRequest, a = { mix: .5 }; for (var r in this.callback = n, this.inputNode = t.context.createGain(), this.convolverNode = t.context.createConvolver(), this.outputNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.inputNode.connect(this.convolverNode), this.convolverNode.connect(this.wetGainNode), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.wetGainNode.connect(this.outputNode), a) this[r] = e[r], this[r] = void 0 === this[r] || null === this[r] ? a[r] : this[r]; if (!e.impulse) { console.error("No impulse file specified."); return } s.open("GET", e.impulse, !0), s.responseType = "arraybuffer", s.onload = function (e) { var n = e.target.response; t.context.decodeAudioData(n, function (e) { o.convolverNode.buffer = e, o.callback && i.Util.isFunction(o.callback) && o.callback() }, function (e) { e = e || Error("Error decoding impulse file"), o.callback && i.Util.isFunction(o.callback) && o.callback(e) }) }, s.onreadystatechange = function (t) { 4 === s.readyState && 200 !== s.status && console.error("Error while fetching " + e.impulse + ". " + s.statusText) }, s.send() }, t.Effects.Convolver.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } } }), t.Effects.PingPongDelay = function (e) { this.options = {}, e = e || this.options; var i = { feedback: .5, time: .3, mix: .5 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), this.delayNodeLeft = t.context.createDelay(), this.delayNodeRight = t.context.createDelay(), this.dryGainNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.feedbackGainNode = t.context.createGain(), this.channelMerger = t.context.createChannelMerger(2), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.delayNodeLeft.connect(this.channelMerger, 0, 0), this.delayNodeRight.connect(this.channelMerger, 0, 1), this.delayNodeLeft.connect(this.delayNodeRight), this.feedbackGainNode.connect(this.delayNodeLeft), this.delayNodeRight.connect(this.feedbackGainNode), this.inputNode.connect(this.feedbackGainNode), this.channelMerger.connect(this.wetGainNode), this.wetGainNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.PingPongDelay.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } }, time: { enumerable: !0, get: function () { return this.options.time }, set: function (e) { i.Util.isInRange(e, 0, 180) && (this.options.time = e, this.delayNodeLeft.delayTime.value = e, this.delayNodeRight.delayTime.value = e) } }, feedback: { enumerable: !0, get: function () { return this.options.feedback }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.feedback = parseFloat(e, 10), this.feedbackGainNode.gain.value = this.feedback) } } }), t.Effects.Reverb = function (e) { this.options = {}, e = e || this.options; var i = { mix: .5, time: .01, decay: .01, reverse: !1 }; for (var n in this.inputNode = t.context.createGain(), this.reverbNode = t.context.createConvolver(), this.outputNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.inputNode.connect(this.reverbNode), this.reverbNode.connect(this.wetGainNode), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.wetGainNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n]; l.bind(this)() }, t.Effects.Reverb.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } }, time: { enumerable: !0, get: function () { return this.options.time }, set: function (e) { i.Util.isInRange(e, 1e-4, 10) && (this.options.time = e, l.bind(this)()) } }, decay: { enumerable: !0, get: function () { return this.options.decay }, set: function (e) { i.Util.isInRange(e, 1e-4, 10) && (this.options.decay = e, l.bind(this)()) } }, reverse: { enumerable: !0, get: function () { return this.options.reverse }, set: function (e) { i.Util.isBool(e) && (this.options.reverse = e, l.bind(this)()) } } }), t.Effects.Tremolo = function (e) { this.options = {}, e = e || this.options; var i = { speed: 4, depth: 1, mix: .8 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.tremoloGainNode = t.context.createGain(), this.tremoloGainNode.gain.value = 0, this.lfoNode = t.context.createOscillator(), this.shaperNode = t.context.createWaveShaper(), this.shaperNode.curve = new Float32Array([0, 1]), this.shaperNode.connect(this.tremoloGainNode.gain), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.lfoNode.connect(this.shaperNode), this.lfoNode.type = "sine", this.lfoNode.start(0), this.inputNode.connect(this.tremoloGainNode), this.tremoloGainNode.connect(this.wetGainNode), this.wetGainNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.Tremolo.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } }, speed: { enumerable: !0, get: function () { return this.options.speed }, set: function (e) { i.Util.isInRange(e, 0, 20) && (this.options.speed = e, this.lfoNode.frequency.value = e) } }, depth: { enumerable: !0, get: function () { return this.options.depth }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.depth = e, this.shaperNode.curve = new Float32Array([1 - e, 1])) } } }), t.Effects.DubDelay = function (e) { this.options = {}, e = e || this.options; var i = { feedback: .6, time: .7, mix: .5, cutoff: 700 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.feedbackGainNode = t.context.createGain(), this.delayNode = t.context.createDelay(), this.bqFilterNode = t.context.createBiquadFilter(), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.inputNode.connect(this.wetGainNode), this.inputNode.connect(this.feedbackGainNode), this.feedbackGainNode.connect(this.bqFilterNode), this.bqFilterNode.connect(this.delayNode), this.delayNode.connect(this.feedbackGainNode), this.delayNode.connect(this.wetGainNode), this.wetGainNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }, t.Effects.DubDelay.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } }, time: { enumerable: !0, get: function () { return this.options.time }, set: function (e) { i.Util.isInRange(e, 0, 180) && (this.options.time = e, this.delayNode.delayTime.value = e) } }, feedback: { enumerable: !0, get: function () { return this.options.feedback }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.feedback = parseFloat(e, 10), this.feedbackGainNode.gain.value = this.feedback) } }, cutoff: { enumerable: !0, get: function () { return this.options.cutoff }, set: function (e) { i.Util.isInRange(e, 0, 4e3) && (this.options.cutoff = e, this.bqFilterNode.frequency.value = this.cutoff) } } }), t.Effects.RingModulator = function (e) { this.options = {}, e = e || this.options; var i = { speed: 30, distortion: 1, mix: .5 }; for (var n in this.inputNode = t.context.createGain(), this.outputNode = t.context.createGain(), this.dryGainNode = t.context.createGain(), this.wetGainNode = t.context.createGain(), this.vIn = t.context.createOscillator(), this.vIn.start(0), this.vInGain = t.context.createGain(), this.vInGain.gain.value = .5, this.vInInverter1 = t.context.createGain(), this.vInInverter1.gain.value = -1, this.vInInverter2 = t.context.createGain(), this.vInInverter2.gain.value = -1, this.vInDiode1 = new f(t.context), this.vInDiode2 = new f(t.context), this.vInInverter3 = t.context.createGain(), this.vInInverter3.gain.value = -1, this.vcInverter1 = t.context.createGain(), this.vcInverter1.gain.value = -1, this.vcDiode3 = new f(t.context), this.vcDiode4 = new f(t.context), this.outGain = t.context.createGain(), this.outGain.gain.value = 3, this.compressor = t.context.createDynamicsCompressor(), this.compressor.threshold.value = -24, this.compressor.ratio.value = 16, this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode), this.inputNode.connect(this.vcInverter1), this.inputNode.connect(this.vcDiode4.node), this.vcInverter1.connect(this.vcDiode3.node), this.vIn.connect(this.vInGain), this.vInGain.connect(this.vInInverter1), this.vInGain.connect(this.vcInverter1), this.vInGain.connect(this.vcDiode4.node), this.vInInverter1.connect(this.vInInverter2), this.vInInverter1.connect(this.vInDiode2.node), this.vInInverter2.connect(this.vInDiode1.node), this.vInDiode1.connect(this.vInInverter3), this.vInDiode2.connect(this.vInInverter3), this.vInInverter3.connect(this.compressor), this.vcDiode3.connect(this.compressor), this.vcDiode4.connect(this.compressor), this.compressor.connect(this.outGain), this.outGain.connect(this.wetGainNode), this.wetGainNode.connect(this.outputNode), i) this[n] = e[n], this[n] = void 0 === this[n] || null === this[n] ? i[n] : this[n] }; var f = function (e) { this.context = e, this.node = this.context.createWaveShaper(), this.vb = .2, this.vl = .4, this.h = 1, this.setCurve() }; function p(e) { for (var t = i.context.sampleRate, n = new Float32Array(t), o = Math.PI / 180, s = 0; s < t; s++) { var a = 2 * s / t - 1; n[s] = (3 + e) * a * 20 * o / (Math.PI + e * Math.abs(a)) } return n } f.prototype.setDistortion = function (e) { return this.h = e, this.setCurve() }, f.prototype.setCurve = function () { var e, t, i, n, o, s, a, r; for (t = 1024, o = new Float32Array(t), e = s = 0, a = o.length; 0 <= a ? s < a : s > a; e = 0 <= a ? ++s : --s)n = (i = Math.abs(i = (e - t / 2) / (t / 2))) <= this.vb ? 0 : this.vb < i && i <= this.vl ? this.h * (Math.pow(i - this.vb, 2) / (2 * this.vl - 2 * this.vb)) : this.h * i - this.h * this.vl + this.h * (Math.pow(this.vl - this.vb, 2) / (2 * this.vl - 2 * this.vb)), o[e] = n; return this.node.curve = o }, f.prototype.connect = function (e) { return this.node.connect(e) }, t.Effects.RingModulator.prototype = Object.create(u, { mix: { enumerable: !0, get: function () { return this.options.mix }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.mix = e, this.dryGainNode.gain.value = t.Util.getDryLevel(this.mix), this.wetGainNode.gain.value = t.Util.getWetLevel(this.mix)) } }, speed: { enumerable: !0, get: function () { return this.options.speed }, set: function (e) { i.Util.isInRange(e, 0, 2e3) && (this.options.speed = e, this.vIn.frequency.value = e) } }, distortion: { enumerable: !0, get: function () { return this.options.distortion }, set: function (e) { if (i.Util.isInRange(e, .2, 50)) { this.options.distortion = parseFloat(e, 10); for (var t = [this.vInDiode1, this.vInDiode2, this.vcDiode3, this.vcDiode4], n = 0, o = t.length; n < o; n++)t[n].setDistortion(e) } } } }), t.Effects.Quadrafuzz = function (e) { this.options = {}, e = e || this.options; var t = { lowGain: .6, midLowGain: .8, midHighGain: .5, highGain: .6 }; this.inputNode = i.context.createGain(), this.outputNode = i.context.createGain(), this.dryGainNode = i.context.createGain(), this.wetGainNode = i.context.createGain(), this.lowpassLeft = i.context.createBiquadFilter(), this.lowpassLeft.type = "lowpass", this.lowpassLeft.frequency.value = 147, this.lowpassLeft.Q.value = .7071, this.bandpass1Left = i.context.createBiquadFilter(), this.bandpass1Left.type = "bandpass", this.bandpass1Left.frequency.value = 587, this.bandpass1Left.Q.value = .7071, this.bandpass2Left = i.context.createBiquadFilter(), this.bandpass2Left.type = "bandpass", this.bandpass2Left.frequency.value = 2490, this.bandpass2Left.Q.value = .7071, this.highpassLeft = i.context.createBiquadFilter(), this.highpassLeft.type = "highpass", this.highpassLeft.frequency.value = 4980, this.highpassLeft.Q.value = .7071, this.overdrives = []; for (var n = 0; n < 4; n++)this.overdrives[n] = i.context.createWaveShaper(), this.overdrives[n].curve = p(); this.inputNode.connect(this.wetGainNode), this.inputNode.connect(this.dryGainNode), this.dryGainNode.connect(this.outputNode); var o = [this.lowpassLeft, this.bandpass1Left, this.bandpass2Left, this.highpassLeft]; for (n = 0; n < o.length; n++)this.wetGainNode.connect(o[n]), o[n].connect(this.overdrives[n]), this.overdrives[n].connect(this.outputNode); for (var s in t) this[s] = e[s], this[s] = void 0 === this[s] || null === this[s] ? t[s] : this[s] }, t.Effects.Quadrafuzz.prototype = Object.create(u, { lowGain: { enumerable: !0, get: function () { return this.options.lowGain }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.lowGain = e, this.overdrives[0].curve = p(i.Util.normalize(this.lowGain, 0, 150))) } }, midLowGain: { enumerable: !0, get: function () { return this.options.midLowGain }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.midLowGain = e, this.overdrives[1].curve = p(i.Util.normalize(this.midLowGain, 0, 150))) } }, midHighGain: { enumerable: !0, get: function () { return this.options.midHighGain }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.midHighGain = e, this.overdrives[2].curve = p(i.Util.normalize(this.midHighGain, 0, 150))) } }, highGain: { enumerable: !0, get: function () { return this.options.highGain }, set: function (e) { i.Util.isInRange(e, 0, 1) && (this.options.highGain = e, this.overdrives[3].curve = p(i.Util.normalize(this.highGain, 0, 150))) } } }) }("undefined" != typeof window ? window : global);